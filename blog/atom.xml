<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://cangulo.github.io/blog</id>
    <title>Carlos Angulo Posts</title>
    <updated>2022-01-22T00:00:00.000Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://cangulo.github.io/blog"/>
    <subtitle>Here you can the general publications I do regarding different subjects as devops or programming üôÇ</subtitle>
    <icon>https://cangulo.github.io/img/favicon.ico</icon>
    <entry>
        <title type="html"><![CDATA[Reducing costs when using AWS Control Tower AFT]]></title>
        <id>aws/1-aws-ct-aft-reduce-cost</id>
        <link href="https://cangulo.github.io/blog/aws/1-aws-ct-aft-reduce-cost"/>
        <updated>2022-01-22T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[This post explains some customizations I did to save costs when using AWS Control Tower after I follow the next article: Manage AWS Accounts Using Control Tower Account Factory for Terraform. I recommend you to read it before continue. Basic knowledge about AWS and Terraform is required.]]></summary>
        <content type="html"><![CDATA[<p>:::info
This post explains some customizations I did to save costs when using AWS Control Tower after I follow the next article: <a href="https://learn.hashicorp.com/tutorials/terraform/aws-control-tower-aft#create-aws-aft-organizational-unit-and-account">Manage AWS Accounts Using Control Tower Account Factory for Terraform</a>. I recommend you to read it before continue. Basic knowledge about AWS and Terraform is required.
:::</p><h2>Context</h2><p>Whenever I want to start a new project, I create a AWS account for each environment to separate domains and costs. So far I have been doing this process manually, but then I discover the Account Factory for Terraform (AFT) as part of the AWS Control Tower services. </p><p>AFT defines a GitOps process to automatize the account creation and update. It is based in two main elements: </p><ol><li>Git repositories, where the account creation request and customizations are defined</li><li>AWS resources (as Pipeline, Dynamo table and step functions) that create the account using the settings defined in the repos. </li></ol><p>I don&#x27;t wan to go into details, but I think it is worth to mention that this automatization can make our life easier, not only because we avoid manual operations (that is always nice, right?). But because it allow us to have common customization along different accounts. </p><p>For example, we can setup a customization for all the AWS accounts to have a default budget policy with a notification when we are close to reach it.(in fact, this was my main goal first, avoid any surprise when testing projects üòÅ). Next are other examples:</p><ul><li>Create default resources as S3 buckets</li><li>Add SSM parameters to describe the account</li><li>Add custom policies</li></ul><h2>Problem: Costs</h2><p>After using it for a few days I notice some AWS resources were increasing the bill. Those were mainly:</p><ol><li>VPC Endpoints: <a href="https://docs.aws.amazon.com/vpc/latest/privatelink/vpc-endpoints.html">billed hourly</a>.</li><li>Other resources related to NAT operations</li></ol><p>I found it in the Cost Explorer of my root account, grouping by API Operation:</p><p><img src="./resources/costs-using-aws-ct-aft.png" alt="costs"/></p><h2>Solution</h2><h3>Delete the VPC Endpoints when not used</h3><p>The AFT repository offers (<a href="https://github.com/aws-ia/terraform-aws-control_tower_account_factory">terraform-aws-control_tower_account_factory</a>) the flag <code>aft_vpc_endpoints</code> to enable/disable the VPC Endpoints. As those are been billed hourly, it doesn&#x27;t make sense to have them on if you are not using them. So, to save costs, only turn them on before executing an account creation request, and once is finished, turn them off. The idea is simple, let&#x27;s see that in practice:</p><p>The basic TF code that creates the AFT infrastructure is:</p><pre><code class="language-terraform">module &quot;aft&quot; {
  source                      = &quot;github.com/aws-ia/terraform-aws-control_tower_account_factory&quot;

  ct_management_account_id    = var.ct_management_account_id
  log_archive_account_id      = var.log_archive_account_id
  audit_account_id            = var.audit_account_id
  aft_management_account_id   = var.aft_management_account_id
  ct_home_region              = var.ct_home_region
  tf_backend_secondary_region = &quot;us-west-2&quot;

  vcs_provider                                  = &quot;github&quot;
  account_request_repo_name                     = &quot;${var.github_username}/learn-terraform-aft-account-request&quot;
  global_customizations_repo_name               = &quot;${var.github_username}/learn-terraform-aft-global-customizations&quot;
  account_customizations_repo_name              = &quot;${var.github_username}/learn-terraform-aft-account-customizations&quot;
  account_provisioning_customizations_repo_name = &quot;${var.github_username}/learn-terraform-aft-account-provisioning-customizations&quot;
}
</code></pre><p>Once we have created the infrastructure by executing a <code>terraform apply</code>, the vpc endpoints are enabled by default, we process to send the account creation request (explained in the tutorial), and then add the flag as next:</p><pre><code class="language-terraform" metastring="{5}">module &quot;aft&quot; {
  source                      = &quot;github.com/aws-ia/terraform-aws-control_tower_account_factory&quot;

  ...

  aft_vpc_endpoints                             = false
}
</code></pre><p>We reexecute <code>terraform apply</code> and done! VPC Endpoint disabled and costs reduces ! </p><h3>Delete the NAT related resources when not used</h3><p>Maybe the first approach we think is to delete the resources manually and then terraform will take care of recreate them if required. However, lets take into account that all the code used by the AFT is based on Terraform and stored in GH, so, we could clone it and adapt it to our needs, well, that is what I did!</p><p>I fork the AWS GH repo <a href="https://github.com/aws-ia/terraform-aws-control_tower_account_factory">aws-ia/terraform-aws-control_tower_account_factory</a> in <a href="https://github.com/cangulo-aws-aft/terraform-aws-control_tower_account_factory">cangulo-aws-aft/terraform-aws-control_tower_account_factory</a>. Then, create a new flag following the <code>aft_vpc_endpoints</code> example is easy, the only work was to find out what resources should depend on the new flag, I name it <code>aft_vpc_aws_nat_gateway</code>. Everything is done in <a href="https://github.com/cangulo-aws-aft/terraform-aws-control_tower_account_factory/commit/d8cfd2584f4cec37e1a91d213f823191cec201d3">this commit</a>.</p><p>Then, we have to update the module &quot;aft&quot; source to our fork and add provide the flag value. Next is the result:</p><pre><code class="language-terraform" metastring="{22}">module &quot;aft&quot; {

  # source = &quot;github.com/cangulo-aws-aft/terraform-aws-control_tower_account_factory&quot;

  # source                      = &quot;github.com/cangulo-aws-aft/terraform-aws-control_tower_account_factory&quot;
  source = &quot;../terraform-aws-control_tower_account_factory&quot;

  ct_management_account_id    = var.ct_management_account_id
  log_archive_account_id      = var.log_archive_account_id
  audit_account_id            = var.audit_account_id
  aft_management_account_id   = var.aft_management_account_id
  ct_home_region              = var.ct_home_region
  tf_backend_secondary_region = var.tf_backend_secondary_region

  vcs_provider                                  = &quot;github&quot;
  account_request_repo_name                     = &quot;${var.github_username}/account-request&quot;
  account_provisioning_customizations_repo_name = &quot;${var.github_username}/account-provisioning-customizations&quot;
  global_customizations_repo_name               = &quot;${var.github_username}/global-customizations&quot;
  account_customizations_repo_name              = &quot;${var.github_username}/account-customizations&quot;

  aft_feature_delete_default_vpcs_enabled = false
  aft_vpc_aws_nat_gateway                 = false
  aft_vpc_endpoints                       = false
}
</code></pre><h2>References:</h2><ul><li>Youtube Tutorial for setting up AWS Control Tower: <a href="https://www.youtube.com/watch?v=CwRy0t8nfgM">Enable AWS Control Tower for Existing Organizations</a>  </li><li><a href="https://learn.hashicorp.com/tutorials/terraform/aws-control-tower-aft#create-aws-aft-organizational-unit-and-account">Manage AWS Accounts Using Control Tower Account Factory for Terraform</a>  </li><li><a href="https://aws.amazon.com/blogs/aws/new-aws-control-tower-account-factory-for-terraform/">Account Factory for Terraform</a></li></ul><h3>Git Repositories</h3><p><a href="https://github.com/hashicorp/learn-terraform-aft-account-provisioning-customizations">learn-terraform-aft-account-provisioning-customizations</a><br/>
<a href="https://github.com/hashicorp/learn-terraform-aft-account-customizations">learn-terraform-aft-account-customizations</a><br/>
<a href="https://github.com/hashicorp/learn-terraform-aft-global-customizations">learn-terraform-aft-global-customizations</a><br/>
<a href="https://github.com/hashicorp/learn-terraform-aft-account-request">learn-terraform-aft-account-request</a></p>]]></content>
        <author>
            <name>Carlos Angulo Mascarell</name>
            <uri>https://github.com/cangulo</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[Interactive bookmarks menu v2]]></title>
        <id>bash/5-interactive-bookmarks-v2</id>
        <link href="https://cangulo.github.io/blog/bash/5-interactive-bookmarks-v2"/>
        <updated>2020-12-21T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[In this post, I am going to improve the interactive bookmark I created in a previous post.]]></summary>
        <content type="html"><![CDATA[<p>In this post, I am going to improve the interactive bookmark I created in a <a href="../1-interactive-bookmarks/1-interactive-bookmarks.mdx">previous post</a>.</p><h2>Requirements</h2><ul><li>Linux (I&#x27;m using <a href="https://elementary.io">Elementary OS</a>, a Ubuntu-based distro, try it!)</li><li><a href="https://github.com/junegunn/fzf">fzf</a> command-line fuzzy finder</li><li>Remember to add execution permissions to the scripts through <code>chmod +x</code></li><li>This article improves the interactive bookmark menu implemented in the previous post: <a href="../1-interactive-bookmarks/1-interactive-bookmarks.mdx"><em>Create an interactive bookmarks menu in your terminal</em></a></li></ul><h2>Improvements introduced</h2><ol><li>Add one directory layer</li><li>Open VS Code in the repository</li></ol><h3>Add one directory layer</h3><p>I have a global path for all the repositories I clone locally, it is <code>/home/cangulo/repos</code>. As I have a lot, I grouped them into folders per organization or custom name.</p><table><thead><tr><th>Organization/ custom name</th><th>Repository</th></tr></thead><tbody><tr><td>cangulo-actions</td><td>cangulo.nuke.prcommitsvalidations</td></tr><tr><td>cangulo-actions</td><td>cangulo.nuke.releasecreator</td></tr><tr><td>cangulo-actions</td><td>workflows</td></tr><tr><td>cangulo-nugets</td><td>cangulo.changelog</td></tr><tr><td>cangulo-nugets</td><td>cangulo.changelog.github.io</td></tr><tr><td>cangulo-nugets</td><td>cangulo.common.testing</td></tr><tr><td>old-projects</td><td>cangulo.build</td></tr><tr><td>old-projects</td><td>cangulo.cicd</td></tr><tr><td>old-projects</td><td>cangulo.cicd-gh-action</td></tr><tr><td>temps</td><td><em>any temporary repository</em></td></tr></tbody></table><p>The <em>organization / custom name</em> will be the first layer, while the repositories are the second one. Next is the folder structure:</p><pre><code class="language-bash">‚îú‚îÄ‚îÄ cangulo-actions
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ cangulo.nuke.prcommitsvalidations
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ cangulo.nuke.releasecreator
‚îÇ¬†¬† ‚îî‚îÄ‚îÄ workflows
‚îú‚îÄ‚îÄ cangulo-nugets
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ cangulo.changelog
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ cangulo.changelog.github.io
‚îÇ¬†¬† ‚îî‚îÄ‚îÄ cangulo.common.testing
‚îú‚îÄ‚îÄ old-projects
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ cangulo.build
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ cangulo.cicd
‚îÇ¬†¬† ‚îî‚îÄ‚îÄ cangulo.cicd-gh-action
‚îî‚îÄ‚îÄ temp
    ‚îú‚îÄ‚îÄ dotnet-docker
    ‚îî‚îÄ‚îÄ gsd
</code></pre><h3>Open VS Code in the repository</h3><p>Once I choose a repository, I would like to open it using VS Code. </p><h3>Demo</h3><p><img src="goal.gif" alt="goal"/></p><h2>Implementation</h2><pre><code class="language-bash" metastring="file=./code/listbookmarks.sh#L3- {4-7,12-17}" file="./code/listbookmarks.sh#L3-"></code></pre><div label="listBookmarks function" link="posts/bash/5-interactive-bookmarks-v2/code/listbookmarks.sh"></div><p>Let me write down the changes introduced:</p><ol><li>Bookmarks now have two properties: <em>name</em> and <em>path</em>. </li></ol><pre><code class="language-json" metastring="file=code/bookmarks.json#L3-L6" file="code/bookmarks.json#L3-L6"></code></pre><ul><li>name: string to identify the organization / custom name folder. Without spaces. e.g. for cangulo-actions -&gt; Actions</li><li>path: full path to first layer directories mentioned before.</li></ul><details><summary>Full Bookmark file</summary><pre><code class="language-json" metastring="file=code/bookmarks.json" file="code/bookmarks.json"></code></pre><div label="bookmarks" link="posts/bash/5-interactive-bookmarks-v2/code/bookmarks.json"></div></details><ol start="2"><li>The path to the bookmarks file is set in the environment variable <code>$BOOKMARKS_FILE</code>. We don&#x27;t have it hardcoded in the function.</li></ol><pre><code class="language-bash" metastring="file=./code/listbookmarks.sh#L5 {1}" file="./code/listbookmarks.sh#L5"></code></pre><ol start="3"><li>I now use <code>jq</code> to query both attributes <code>(.[] | [.name,.path])</code> and output them in the columns <code>[&quot;NAME&quot;, &quot;PATH&quot;]</code>  as a tab-separated-value <code>@tsv</code>:</li></ol><pre><code class="language-bash" metastring="file=./code/listbookmarks.sh#L5-L8" file="./code/listbookmarks.sh#L5-L8"></code></pre><p><img src="jq-updated.png" alt="jq-updated"/></p><p>Problem: columns are not aligned (see <em>oldprojects</em> row)</p><ol start="4"><li>In order to align the <code>jq</code> output before piping it to <code>fzf</code>, I use the <code>column -t</code> command. <a href="https://linux.die.net/man/1/column">Reference</a></li></ol><pre><code class="language-bash" metastring="file=./code/listbookmarks.sh#L5-L10 {5}" file="./code/listbookmarks.sh#L5-L10"></code></pre><p><img src="column.png" alt="column"/></p><ol start="5"><li>Once a bookmark is selected, the full row is returned. I</li></ol><p><img src="fzf_return_full_row.gif" alt="fzf_return_full_row"/></p><p>Then, I have to extract the path. First, I delete the repeated spaces (<code>tr -s &#x27; &#x27;</code>). Secondly, I choose the second column(<code>cut -f2 -d &#x27; &#x27;</code>). The <code>-d &#x27; &#x27;</code> parameter is to set columns delimiter to a whitespace.</p><p><img src="trim-selection.png" alt="trim-selection"/></p><ol start="5"><li>I have created the function <code>lsf</code> to list the current directories using <code>fzf</code>, navigate to the one selected and execute a command provided as first parameter <code>$1</code>. In our case <code>code</code>. </li></ol><pre><code class="language-bash" metastring="file=./code/listbookmarks.sh#L27-L37 {8}" file="./code/listbookmarks.sh#L27-L37"></code></pre><p>Please note the <code> eval &quot;\$command .&quot;</code> statement for executing the command provided.</p><h2>Adding this to your Terminal Profile</h2><p>You can add this into your Bash / Zsh profile. You can follow the next steps:</p><ol><li>Define your bookmarks in a json file following the <em>name,path</em> model</li><li>In your profile, append its path in the <code>$BOOKMARKS_FILE</code> variable</li><li>Append the functions <code>listBookmarks</code> and <code>lsf</code>.</li><li>Append a call to the <code>listBookmarks</code> function at the end of the profile, so every time you open a terminal it execute it. </li></ol><h2>lsf function</h2><p>I just want to mention you can use the  <code>lsf</code> function separately to make navigation through directories faster. Also, remember it accepts as a parameter a command to execute in the directory selected. Give it a try and add import it in your profile.</p><p><img src="lsf_faster_navigation.gif" alt="lsf_faster_navigation"/></p><h2>Final Notes</h2><p>Do you see any other improvement to include? What commands would you provide when using <code>lsf</code> ? Share them in the comments below.</p><div id="UtEUhkfriklonVdweC"></div>]]></content>
        <author>
            <name>Carlos Angulo Mascarell</name>
            <uri>https://github.com/cangulo</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[How to use a repository for importing your bash scripts and shortcuts]]></title>
        <id>bash/4-create-config-repo</id>
        <link href="https://cangulo.github.io/blog/bash/4-create-config-repo"/>
        <updated>2020-12-17T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[In this post, I will explain how to load custom variables by reading a JSON file, this will be done every time we open a Terminal. I will also improve the shortcuts we create in the previous posts.]]></summary>
        <content type="html"><![CDATA[<p>In this post, I will explain how to load custom variables by reading a JSON file, this will be done every time we open a Terminal. I will also improve the shortcuts we create in the previous posts.</p><p>:::info Template ready to use!
The <a href="https://github.com/cangulo-templates/linux-terminal-profile">cangulo-templates/linux-terminal-profile</a> repository contains a ready-to-use template based on this article.
:::</p><h2>Requirements</h2><ul><li>Linux (I&#x27;m using <a href="https://elementary.io">Elementary OS</a>, a Ubuntu-based distro, try it!)</li><li><a href="https://code.visualstudio.com">VS Code</a>. If you don&#x27;t want to use it, change all the <code>code</code> commands in the bash code for your text editor. Alternatives: <em>gedit</em> or <a href="https://gitlab.gnome.org/GNOME/gnome-text-editor">gnome-text-editor</a>.</li><li><a href="https://github.com/junegunn/fzf">fzf</a> command-line fuzzy finder</li></ul><h2>Notes</h2><ul><li>Remember to add execution permissions to the scripts through <code>chmod +x</code></li><li>Profile script: <code>$HOME/.bashrc</code> for bash terminal and <code>$HOME/.zshrc</code> for zsh </li></ul><h2>Problem</h2><p>Simplify, as much as possible, the process to set up my shortcuts every time I migrate to a new computer, personal or work. This process is: download and setups all my scripts in the Bash profile.</p><h2>Idea</h2><p>Remember the concept <em>Behavior vs Configuration</em> I explained in my <a href="../3-load-vars/3-load-vars.mdx#behavior-vs-configuration">previous post</a>? We are going to continue using it üòÅ. Let me list down the main points:</p><ul><li>Variables are stored in a JSON file. We want those variables to be available during all the terminal sessions.</li><li>Functions depend on those variables, values that could change depending on the PC your use, for example paths, shouldn&#x27;t be hard-coded.</li><li>Both, variables and functions are added in the Bash Profile.</li></ul><p>Nice, now that we have the main points, let me show the implementation.</p><h2>Implementation</h2><p>First, we have the JSON file containing the variables:</p><pre><code class="language-json" metastring="file=./code/1-profile-settings.json" file="./code/1-profile-settings.json"></code></pre><p>Each JSON key will be an environment variable, I prefer to define them in upper case to differentiate them from other variables we define during the terminal session.</p><p>Then, in the bash profile we only have to do the next actions:</p><ol><li>Export the path to the JSON settings. My convention is to call this variable as <code>SETTINGS_FILE</code>.</li><li>Call a script to load all the variables and functions using the previous settings. Let&#x27;s call this script <code>load-custom-profile.sh</code>.</li></ol><p>Next is the code for that. Please append it in your profile.</p><pre><code class="language-bash"># Update FULL_PATH_TO_JSON_SETTINGS with yours
export SETTINGS_FILE=&quot;FULL_PATH_TO_JSON_SETTINGS&quot;
source FULL_PATH/load-custom-profile.sh
</code></pre><p>Please note we use the <code>export</code> keyword, which sets <code>SETTINGS_FILE</code> as an environment variable. In that way, it will be available for other scripts. Please check this <a href="https://www.baeldung.com/linux/bash-variables-export">link</a> for more details.</p><h3>load-custom-profile.sh</h3><p>This script should perform the next actions:</p><ul><li>Verify <code>$SETTINGS_FILE</code> is defined and valid:<ul><li>String is not empty</li><li>Path provided exists</li></ul></li><li>Read the JSON file and export the variables. The command is based on <code>jq</code> and <code>eval</code> as explained in my <a href="../3-load-vars/3-load-vars.mdx">previous post</a> for more details. The main difference now is the use of the <code>export</code> command, following the pattern: <code>export KEY=&#x27;VALUE&#x27;</code></li></ul><pre><code class="language-bash" metastring="file=./code/load-custom-profile.sh" file="./code/load-custom-profile.sh"></code></pre><p>Next are the scripts stored in <code>$SCRIPTS_FOLDER</code>:</p><ul><li>aliases:</li></ul><div><div value="bash" label="bash" default=""><pre><code class="language-bash" metastring="file=./code/scripts/aliases-bash.sh" file="./code/scripts/aliases-bash.sh"></code></pre><div label="aliases-bash.sh" link="posts/bash/4-create-config-repo/code/scripts/aliases-bash.sh"></div></div><div value="zsh" label="zsh"><pre><code class="language-bash" metastring="file=./code/scripts/aliases-zsh.sh" file="./code/scripts/aliases-zsh.sh"></code></pre><div label="aliases-zsh.sh" link="posts/bash/4-create-config-repo/code/scripts/aliases-zsh.sh"></div></div></div><ul><li>functions:</li></ul><pre><code class="language-bash" metastring="file=./code/scripts/functions.sh" file="./code/scripts/functions.sh"></code></pre><ul><li>Bookmarks file referenced in the variable <code>BOOKMARKS_FILE</code> , and used in the <code>listBookmarks</code>  function:</li></ul><pre><code class="language-json" metastring="file=./code/2-bookmarks.json" file="./code/2-bookmarks.json"></code></pre><h2>Demo</h2><p><img src="demo.gif" alt="demo"/></p><h2>Repository</h2><p>If we store the settings and the implementations in a repository (e.g. GitHub) , we just need to reference them in the profile script the same way we have done so far:</p><pre><code class="language-bash"># Update LOCAL_REPO_FULL_PATH with yours
export SETTINGS_FILE=&quot;LOCAL_REPO_FULL_PATH/settings.local.json&quot;
source LOCAL_REPO_FULL_PATH/load-custom-profile.sh
</code></pre><p>I recommend you to have a <code>settings.template.json</code> with the empty variables as next:</p><pre><code class="language-json" metastring="file=./code/3-profile-settings.template.json" file="./code/3-profile-settings.template.json"></code></pre><p>In that way, when you clone the repo locally, you duplicate it, rename copy to <code>settings.local.json</code>, and fill the values. Add it to your <code>gitignore</code> to avoid pushing it.</p><h2>Final Notes</h2><p>wow, this post is the longest one I have done so far! Do you have another approach for importing scripts or settings? How would you do it? Let me know in the comments below.</p><div id="d3mlE7uhX8KFgEmY"></div>]]></content>
        <author>
            <name>Carlos Angulo Mascarell</name>
            <uri>https://github.com/cangulo</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[Load custom variables at Terminal startup]]></title>
        <id>bash/3-load-vars</id>
        <link href="https://cangulo.github.io/blog/bash/3-load-vars"/>
        <updated>2020-12-15T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[In this post, I will explain how to import custom environment variables from a JSON file.]]></summary>
        <content type="html"><![CDATA[<p>In this post, I will explain how to import custom environment variables from a JSON file.
I will also improve the shortcuts we create in the previous posts.</p><h2>Requirements</h2><ul><li>Linux (I&#x27;m using <a href="https://elementary.io">Elementary OS</a>, a Ubuntu-based distro, try it!)</li><li><a href="https://code.visualstudio.com">VS Code</a>. If you don&#x27;t want to use it, change all the <code>code</code> commands in the bash code for your text editor. Alternatives: <em>gedit</em> or <a href="https://gitlab.gnome.org/GNOME/gnome-text-editor">gnome-text-editor</a>.</li><li><a href="https://github.com/junegunn/fzf">fzf</a> command-line fuzzy finder</li></ul><h2>Notes</h2><ul><li>Remember to add execution permissions to the scripts through <code>chmod +x</code></li><li>Profile script: <code>$HOME/.bashrc</code> for bash terminal and <code>$HOME/.zshrc</code> for zsh </li></ul><h2>Variables</h2><p>Let&#x27;s say I want to define some variables as:</p><ul><li>my local github repositories path</li><li>my documents path</li><li>path to a specific file, in this case, the path to a JSON file containing some bookmarks I have, check my <a href="../1-interactive-bookmarks/1-interactive-bookmarks.mdx">previous post</a></li></ul><p>By defining them in the profile script as:</p><pre><code class="language-bash" metastring="file=./code/1-declare-vars.sh#L3-" file="./code/1-declare-vars.sh#L3-"></code></pre><p>We can use them during the terminal session.</p><p><img src="use-localrepo-variable.gif" alt="using the variables after loading the terminal"/></p><p>Let&#x27;s append the next function and aliases at the bash profile. Please note those are using the variables defined before.</p><pre><code class="language-bash" metastring="file=./code/2-add-functions.sh#L3-" file="./code/2-add-functions.sh#L3-"></code></pre><p>Now, we can use them after opening the Terminal.</p><p><img src="use-gotoRepos-function.gif" alt="using the variables after loading the terminal"/></p><h2>Behavior vs Configuration</h2><p>In <a href="../1-interactive-bookmarks/1-interactive-bookmarks.mdx">a previous post</a>, the <code>listBookmarks</code> function has the <code>bookmarksFile</code> hardcoded. </p><pre><code class="language-bash" metastring="file=../1-interactive-bookmarks/code/listbookmarks.sh#L3-L4" file="../1-interactive-bookmarks/code/listbookmarks.sh#L3-L4"></code></pre><p>As you see, its value refers to the <code>bookmarks.json</code> location. What happens if we move that file to another folder? We would have to update the function. For one variable this doesn&#x27;t seem to be a problem, right? But what if it is hardcoded in more functions? we would have to update them all, that is not extensible!</p><p>Let&#x27;s define two terms here:</p><ul><li>Behavior: Functions implementation.</li><li>Configuration: Input parameters that the function relies on. In this case, <code>bookmarksFile</code>. </li></ul><p>By setting all the parameters outside the functions, we are creating a central place for the configuration.</p><pre><code class="language-bash" metastring="file=./code/1-declare-vars.sh#L4-" file="./code/1-declare-vars.sh#L4-"></code></pre><p>And by calling those from the functions:</p><pre><code class="language-bash" metastring="file=./code/2-add-functions.sh#L8-L9" file="./code/2-add-functions.sh#L8-L9"></code></pre><p>We are <strong>decoupling</strong> configuration from behavior.  If we want to migrate or share this setup, we won&#x27;t need to look at the function implementations, we would only need to update the parameters.</p><div id="d3mlE7uhX8KFgEmY"></div><h2>One extra mile: Define the parameters as JSON</h2><p>Let&#x27;s migrate the variables to a JSON file as follows. Please note all the paths are now absolute.</p><pre><code class="language-json" metastring="file=./code/3-vars.json" file="./code/3-vars.json"></code></pre><p>To set the JSON keys as the parameters name we have to:</p><ol><li>Define the json file path. We will consider those as the main settings.</li><li>Use the <code>jq</code> command to retrieve the keys and values.</li><li>Use the <code>eval</code> command to execute the <code>key=value</code>  for each one.</li></ol><p>Next is the solution, replace the variables declaration in your profile for this.</p><pre><code class="language-bash">settingsFile=&quot;/home/cangulo/repos/cangulo-blog/cangulo.github.io/blog/posts/bash/3-setup-custom-env-variables/code/3-vars.json&quot;
eval &quot;$(jq -r &#x27;to_entries | .[] | .key + &quot;=&quot; + (.value | @sh)&#x27; &lt;$settingsFile)&quot;
</code></pre><details><summary>In case you want to go into the solution details. Click here.</summary><p>References:</p><ul><li>Settings json keys as variables<code>jq</code>. <a href="https://unix.stackexchange.com/a/413886">Link</a></li><li>What <code>@sh</code> means in <code>jq</code>. Quote string for bash. <a href="https://stedolan.github.io/jq/manual/">Link</a></li></ul><p><code>jq -r &#x27;to_entries&#x27;</code>  structures the json as key/value pair array:</p><p><img src="./details/1-to_entries.png" alt="1-to_entries.png"/></p><p><code>jq -r &#x27;to_entries | .[]&#x27;</code>  prepare the array items for the iteration:</p><p><img src="./details/2-iterate-over-array-items.png" alt="2-iterate-over-array-items.png"/></p><p><code>jq -r &#x27;to_entries | .[] | .key + &quot;=&quot; + .value&#x27;</code> build the <code>key=value</code> expressions </p><p><img src="./details/3-build-variable-declaration-code.png" alt="3-build-variable-declaration-code.png"/></p><p><code>jq -r &#x27;to_entries | .[] | .key + &quot;=&quot; + (.value | @sh)&#x27;</code> format the expression
<img src="./details/4-format-declaration.png" alt="4-format-declaration.png"/></p></details><p>Nothing more for Today! Do you think this is a good approach? How would you do it? Let me know in the comments below.</p>]]></content>
        <author>
            <name>Carlos Angulo Mascarell</name>
            <uri>https://github.com/cangulo</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[Add shortcuts to your bash terminal]]></title>
        <id>bash/2-add-shortcuts</id>
        <link href="https://cangulo.github.io/blog/bash/2-add-shortcuts"/>
        <updated>2020-12-14T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[In this post, I will define shortcuts in my bash terminal. The implementation is based on using aliases and functions. Super simple!]]></summary>
        <content type="html"><![CDATA[<p>In this post, I will define shortcuts in my bash terminal. The implementation is based on using aliases and functions. Super simple!</p><h2>Requirements</h2><ul><li>Linux (I&#x27;m using <a href="https://elementary.io">Elementary OS</a>, a Ubuntu-based distro, try it!)</li><li><a href="https://code.visualstudio.com">VS Code</a>. If you don&#x27;t want to use it, change all the <code>code</code> commands in the bash code for your text editor. Alternatives: <em>gedit</em> or <a href="https://gitlab.gnome.org/GNOME/gnome-text-editor">gnome-text-editor</a>.</li><li>Remember to add execution permissions to the scripts through <code>chmod +x</code></li></ul><h2>Aliases</h2><p>You can create <strong>aliases</strong> to avoid type long commands. Next are some examples:</p><div><div value="bash" label="bash" default=""><pre><code class="language-bash" metastring="file=./code/scripts/aliases-bash.sh#L3-" file="./code/scripts/aliases-bash.sh#L3-"></code></pre><div label="aliases-bash.sh" link="posts/bash/2-add-shortcuts/code/scripts/aliases-bash.sh"></div></div><div value="zsh" label="zsh"><pre><code class="language-bash" metastring="file=./code/scripts/aliases-zsh.sh#L3-" file="./code/scripts/aliases-zsh.sh#L3-"></code></pre><div label="aliases-zsh.sh" link="posts/bash/2-add-shortcuts/code/scripts/aliases-zsh.sh"></div></div></div><p><img src="goToReposExecution.gif" alt="goToReposExecution"/></p><p>Please note <code>$HOME</code> is an environment variable defined by the system, it refers to your home path, in my case <code>/home/carlos</code>.</p><h2>Functions</h2><p>You can also define functions as shortcuts for daily tasks. I have the next ones:</p><pre><code class="language-bash" metastring="file=./code/scripts/functions.sh" file="./code/scripts/functions.sh"></code></pre><p><em>No need to focus on the implementation, I just want to point out some examples.</em></p><p><img src="functionsExecution.gif" alt="functionsExecution"/></p><h2>How to integrate those shortcuts in the bash terminal?</h2><p>In order to load the shortcuts every time we open a terminal, we have to append them in the shell profile (<code>$HOME/.bashrc</code> for bash terminal, and <code>$HOME/.zshrc</code> for zsh). </p><p>However, the profile script will become bigger for every new shortcut we add, to make this extensible we will <em>source</em> (<a href="https://linuxize.com/post/bash-source-command/">load</a>) the shortcuts from separate scripts. Let me list them:</p><ol><li><code>alias-bash.sh.sh</code> /  <code>alias-zsh.sh</code></li><li><code>functions.sh</code></li></ol><p>Append the next code to your profile:</p><pre><code class="language-bash" metastring="file=./code/sourceScripts.sh" file="./code/sourceScripts.sh"></code></pre><details><summary>Some notes about loading the functions:</summary><p>if you want to use the functions in scripts that you call manually from the terminal, you have to <code>export</code> them as next:</p><div><div value="bash" label="bash" default=""><pre><code class="language-bash">funcName(){

}
export -f funcName
</code></pre></div><div value="zsh" label="zsh"><pre><code class="language-bash">funcName(){

}
export funcName
</code></pre></div></div><p><a href="https://www.baeldung.com/linux/bash-variables-export">reference</a></p></details><p>Nothing else! I hope this saves you some time using the terminal. Do you have similar shortcuts? Share them in the comments below.</p><div id="ZVik7pBtu9dNS"></div>]]></content>
        <author>
            <name>Carlos Angulo Mascarell</name>
            <uri>https://github.com/cangulo</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[Create an interactive bookmarks menu in your terminal]]></title>
        <id>bash/1-interactive-bookmarks</id>
        <link href="https://cangulo.github.io/blog/bash/1-interactive-bookmarks"/>
        <updated>2020-12-11T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[In this post, I am going to implement an interactive bookmarks menu using fzf in bash Terminal.]]></summary>
        <content type="html"><![CDATA[<p>In this post, I am going to implement an interactive bookmarks menu using fzf in bash Terminal.</p><h2>Requirements</h2><ul><li>Linux (I&#x27;m using <a href="https://elementary.io">Elementary OS</a>, a Ubuntu-based distro, try it!)</li><li><a href="https://github.com/junegunn/fzf">fzf</a> command-line fuzzy finder</li><li>Remember to add execution permissions to the scripts through <code>chmod +x</code></li></ul><h2>Demo</h2><p><img src="goal.gif" alt="goal"/></p><p>As you see, every time I call <code>listBookmarks</code> the following paths are listed interactively:</p><ul><li>/home/cangulo/repos/cangulo-tf</li><li>/home/cangulo/repos/cangulo-nuke</li></ul><p>I can move through them using the up/down keys, and navigate into by pressing Enter.</p><p>On the other hand, in case similar paths are listed, I can filter by typing keywords.</p><p><img src="demo_filter.gif" alt="goal"/></p><h2>Implementation</h2><pre><code class="language-bash" metastring="file=./code/listbookmarks.sh" file="./code/listbookmarks.sh"></code></pre><div label="listBookmarks function" link="posts/bash/1-interactive-bookmarks/code/listbookmarks.sh"></div><p>Let me define the basic structure:</p><ol><li>Read the paths (i.e. <em>bookmarks</em>)</li><li>List them in an interactive way</li><li>Once a bookmark is selected, navigate to it</li></ol><p>Now let&#x27;s dive into the details:</p><h3>1. Read the bookmarks</h3><p>First, in order to make this extensible, the paths are listed in a JSON file:</p><pre><code class="language-json" metastring="file=code/bookmarks.json" file="code/bookmarks.json"></code></pre><div label="bookmarks" link="posts/bash/1-interactive-bookmarks/code/bookmarks.json"></div><p>We can print the file content using <code>cat</code>, and then use <code>jq</code> to query the array items. </p><p><code>cat $bookmarksFile  | jq -r &#x27;.[]&#x27;</code></p><details><summary>Why I&#x27;m using a JSON file instead of a simple text file. Click here for the answer:</summary><p>It is because in the article <a href="../5-interactive-bookmarks-v2/5-interactive-bookmarks-v2.mdx">Interactive bookmarks menu v2</a> I will add new features with more advanced bookmarks üòÅ</p></details><h3>2. List the bookmarks</h3><p>Here is where <code>fzf</code> comes up. Anything that <code>fzf</code>  receives is listed interactively. In this case, we pipe the <code>jq</code> result to <code>fzf</code>, so the bookmarks are listed as shown in the <a href="#demo">demo</a> section.</p><p><code>cat $bookmarksFile | jq -r &#x27;.[]&#x27; | fzf</code></p><h3>3. Once a bookmark is selected, navigate to it</h3><p><code>fzf</code> returns the path selected, we save it to a variable.</p><p><code>local pathSelected=$(cat $bookmarksFile | jq -r &#x27;.[]&#x27; | fzf)</code></p><p>Last, we check if it is not empty (<code>-n</code>) before moving into:</p><pre><code class="language-bash">if [[ -n &quot;$pathSelected&quot; ]]; then
    cd $pathSelected
else
    echo &quot;no bookmark selected&quot;
fi
</code></pre><h2>Bonus: execute this every time you open a terminal</h2><p>You have to add this in your bash or zsh profile (<em>.bashrc</em>, <em>.zshrc</em> ). Just append the <code>listBookmarks</code> implementation at the end, update the <code>bookmarksFile</code> variable to be a full path, and call the function.</p><pre><code class="language-bash">listBookmarks() {
    local bookmarksFile=&#x27;YOUR_PATH/bookmarks.json&#x27;
    local pathSelected=$(cat $bookmarksFile |
        jq -r &#x27;.[]&#x27; |
        fzf)

    if [[ -n &quot;$pathSelected&quot; ]]; then
        cd $pathSelected
    else
        echo &quot;no bookmark selected&quot;
    fi
}

listBookmarks
</code></pre><p>And that is all! I hope this saves you some time using the terminal. Do you find this useful? Do you have similar functions? Let me know in the comments below.</p><div id="xUPOqo6E1XvWXwlCyQ"></div>]]></content>
        <author>
            <name>Carlos Angulo Mascarell</name>
            <uri>https://github.com/cangulo</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[How to use the PowerShell Profile to be more productive]]></title>
        <id>ps-profile-productive</id>
        <link href="https://cangulo.github.io/blog/ps-profile-productive"/>
        <updated>2020-08-24T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[In this post, I will explain how to set up shortcuts in the PowerShell Profile. Everything in this article works for PowerShell 5.1 and later.]]></summary>
        <content type="html"><![CDATA[<p>In this post, I will explain how to set up shortcuts in the PowerShell Profile. Everything in this article works for PowerShell 5.1 and later.</p><p>If you are a PowerShell (a.k.a. PS) user, I&#x27;m sure at some point you repeat operations as navigating to a specific folder (e.g. your local GitHub repository). Maybe you run a script to clean or prepare your environment. Let&#x27;s define those two scenarios as next:</p><ol><li>Go to your local git repository folder.<ul><li>Code to execute: <code>cd .\source\repos\</code></li></ul></li><li>Execute a script.<ul><li>Code to execute: <code>$HOME\source\repos\TaskManager\startTaskManagerScript.ps1</code></li></ul></li></ol><h2>What is the PS Profile?</h2><p>The PS Profile is a script that is run when the console starts, setting custom user settings as variables, aliases or functions. We can also use it to execute custom commands to prepare our local environment. Check your <code>$Profile</code> variable to know where your profile is stored.</p><p><img src="./2020-08-26-configuring-powershell-profile/Profile-variable.png" alt="Profile variables"/></p><h2>Shortcuts</h2><p>The shortcuts we are going to set are functions or aliases depending on the following situations:</p><ol><li>For a command with static parameters, we will write functions. For example, <code>goToRepos</code> as a shortcut for <code>cd $HOME\source\repos</code>. The code will be:</li></ol><p><code>function NAME { COMMAND_WITH_PARAMS }</code> -&gt; <code>function goToRepos { cd $HOME\source\repos }</code></p><ol start="2"><li>We will define an alias for frequently used commands which we call with different parameters. For example, we use <code>Select-String</code> to filter file content as next:</li></ol><pre><code class="language-powershell">Select-String [-Pattern] PATTERN [-Path] PATH
</code></pre><p><img src="ss-executed.png"/></p><p>Instead of writing <code>Select-String</code>, we could write <code>ss</code>. Next is the alias:</p><p><code>New-Alias -Name ALIAS -Value COMMAND</code> -&gt; <code>New-Alias -Name ss -Value Select-String</code></p><p>In our case, we want to avoid typing the full <em>startTaskManagerScript</em>, so we set that path as COMMAND.</p><p><code>New-Alias -Name startTaskManagerAPI -Value $HOME\source\repos\TaskManager\startTaskManagerScript.ps1</code></p><h3>Creating the profile</h3><p>Let&#x27;s create and open the PS profile, execute the following command in PS: <code>code $PROFILE</code>, you should see the code editor empty. Considering that both commands share the <code>$HOME\source\repos</code> path, we could define a variable to short them as next:</p><pre><code class="language-powershell"># Variables

$localRepo = $HOME + &#x27;\source\repos&#x27;

# Functions

function goToRepos { cd $localRepo }

# Alias

New-Alias -Name startTaskManagerAPI -Value $localRepo\TaskManager\startTaskManagerScript.ps1
</code></pre><p>Please note the <code>$localrepo</code> variable will be available during the PS session. This means you can use it anytime, just as the variable <code>$HOME</code>. Paste the previous code into your profile and save it.</p><p>Open a new PS window. Maybe the next error will show up:</p><p><img src="./2020-08-26-configuring-powershell-profile/digitally-signed-problem.png" alt="Problem Signature Profile"/></p><p>That is because PS has an execution policy that only accepts signed scripts (<code>AllSigned</code>). We need to change it to <code>RemoteSigned</code> to verify the signature for remote scripts, but not locals. We have to do it using the following command:</p><p><code>Set-ExecutionPolicy RemoteSigned -Scope CurrentUser</code>. Now we are good to go, open a new PS and try to execute the shortcuts we defined. </p><p><img src="./2020-08-26-configuring-powershell-profile/shortcuts-execution.png" alt="Shortcuts execution"/></p><p>:::tip use the autocomplete feature!
You don&#x27;t need to write your aliases or functions completely. Just type the initial part and press <code>tab</code>.
:::</p><p>And we&#x27;re done! I hope this helps you to save time when using PS. Do you know any other tweak to be more productive? Feel free to share it in the comments!</p><h2>References</h2><ul><li><a href="https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_profiles?view=powershell-5.1">PowerShell Profiles Reference for PS 5.1</a></li><li><a href="https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_profiles?view=powershell-5.1#the-profile-files">Profiles Files in PS 5.1</a></li><li><a href="https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.utility/set-alias?view=powershell-5.1#example-4--create-an-alias-to-an-executable-file">Example 4: Create an alias to an executable file</a></li><li><a href="https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.utility/set-alias?view=powershell-5.1#example-4--create-an-alias-to-an-executable-file">Example 5: Create an alias for a command with parameters</a></li><li><a href="https://www.tenforums.com/general-support/107659-how-sign-powershell-profile-w-self-signed-certificate.html">How to sign PowerShell profile w/ self-signed certificate?</a></li><li><a href="https://www.hanselman.com/blog/SigningPowerShellScripts.aspx">Signing PowerShell Scripts</a></li></ul>]]></content>
        <author>
            <name>Carlos Angulo Mascarell</name>
            <uri>https://github.com/cangulo</uri>
        </author>
    </entry>
</feed>